

---Funciones


---SUM, MAX, MIN, AVG, TRIM, LTRIM, 


----sintaxis

---CREATE FUNCTION NOMBRE_FUNCION (@VARIABLE VARCHAR(8))
---RETURN VARCHAR(8)
---AS
---     BEGIN
---	 ---DECLARO TODO EL PROCESO DE LA FUNCION
---	 ---TRANSACT SQL SERVER 
---
---	 END

---6758----00006758
---CREAMOS UNA FUNCION QUE PERMITA SIEMPRE RETORMAR UN DATO DE UN DOCUMENTO CON UNA LONGITUD
---DE 8 CARACTERES 

CREATE FUNCTION FN_LIMPIEZADOCUMENTO (@DNI VARCHAR(8))
RETURNS VARCHAR(8)
AS 
   BEGIN 
   DECLARE @DNILIMPIO VARCHAR(8)
   
   SET @DNILIMPIO= RIGHT('00000000'+RTRIM(LTRIM(@DNI)),8)-----RIGHT CORTA 8 POSICIONES DE IZQUIER A DERECHA 
                                                         -----POR EJEMPLO 00070547212 A 70547212
   RETURN @DNILIMPIO                                     -----TE AHORRA USAR TRANSACT

   END

----CREANDO TABLA 

CREATE TABLE TB_EMPLEADOS (DNI VARCHAR(8), NOMBRE VARCHAR(50))
INSERT INTO TB_EMPLEADOS VALUES('0908','JEAN PIERRE')
INSERT INTO TB_EMPLEADOS VALUES('05608','JUAN')
INSERT INTO TB_EMPLEADOS VALUES('0508','JOSE')
INSERT INTO TB_EMPLEADOS VALUES('0308','PEDRO')

SELECT A.DNI, A.NOMBRE,[dbo].[FN_LIMPIEZADOCUMENTO](A.DNI) AS CAMPO_NUEVO
FROM TB_EMPLEADOS A 

----CALCULO DEL IGV

SELECT A.OrderID, A.Freight*1.18 as VTA_IGV, A.Freight AS VENTA
FROM dbo.Orders A

CREATE FUNCTION FN_CALCULO_IGV (@MONTO FLOAT)
RETURNS FLOAT
AS 
   BEGIN
   DECLARE @MONTO_IGV FLOAT
   SET @MONTO_IGV=@MONTO*1.18
   RETURN @MONTO_IGV
   END
-----UTILIZANDO LA FUNCION
SELECT A.OrderID, A.Freight*1.18 as VTA_IGV,dbo.FN_CALCULO_IGV(A.Freight) AS VTA_IGV_2, A.Freight AS VENTA

FROM dbo.Orders A
-----ACTUALIZANDO LA FUNCION 
ALTER FUNCTION FN_CALCULO_IGV (@MONTO FLOAT)
RETURNS FLOAT
AS 
   BEGIN
   DECLARE @MONTO_IGV FLOAT
   SET @MONTO_IGV=@MONTO*1.19
   RETURN @MONTO_IGV
   END

-------UTILIZANDO LA FUNCION - DESPUES DE HABER ACTUALIZADO EL PORCENTAJE DE IGV
SELECT A.OrderID, A.Freight*1.18 as VTA_IGV,dbo.FN_CALCULO_IGV(A.Freight) AS VTA_IGV_2, A.Freight AS VENTA

FROM dbo.Orders A

----Funcion que retorne una tabla 

CREATE FUNCTION FN_CLIENTE_SUMA(@ID_CUSTOMER NCHAR(5))
RETURNS TABLE 
AS RETURN(
        select A.CustomerID, SUM(B.Freight) AS VENTA 
        FROM Customers A
        INNER JOIN Orders B ON A.CustomerID=B.CustomerID
        WHERE A.CustomerID=@ID_CUSTOMER
        GROUP BY A.CustomerID)

SELECT *
FROM Customers

---ANTON
---AROUT
---CONSULTANDO LA FUNCION
SELECT *
FROM DBO.FN_CLIENTE_SUMA('AROUT')
---APLLY
---CROSS APPLY ---FUNCIONA COMO UN INNER JOIN PERO EXCLUSIVAMENTE PARA FUNCIONES 

SELECT *
FROM CUSTOMERS A
CROSS APPLY  DBO.FN_CLIENTE_SUMA(A.CustomerID) B---CRUZA SEGUN LA FUNCION 

---OUTER APPLY ---FUNCIONA COMO UN LEFT JOIN EXCLUSIVAMENTE PARA FUNCIONES 

SELECT *
FROM CUSTOMERS A
OUTER APPLY  DBO.FN_CLIENTE_SUMA(A.CustomerID) B

---------------------------------------------------------------------	
-------PROCEDURES ----PROCESOS QUE VAMOS A CREAR RETORNA EJECUTA UNA TRANSACCION SINTAXIS DML
----SINTAXIS
--CREATE PROCEDURE SP_NOMBRE_PROCEDURE (@VARIABLE TIPO_DATO)
--AS 
--BEGIN
------TRANSACT SQL----INSERT, DELETE, UPDATE, SELECT
--END
--------------PROCEDURE QUE ME RETORNE UN SELECT 
CREATE PROCEDURE SP_VENTAS_CLIENTES 
AS
BEGIN

        SELECT A.CustomerID, SUM(B.Freight) AS VENTA 
        FROM Customers A
        INNER JOIN Orders B ON A.CustomerID=B.CustomerID
        GROUP BY A.CustomerID
END

---LLAMANDO AL PROCEDURE

EXECUTE SP_VENTAS_CLIENTES

----------------------------OTRO EJEMPLO DE PROCEDURE
DROP TABLE AGR_CLIENTES 
CREATE TABLE AGR_CLIENTES (
CUSTOMER_ID CHAR(5),
NOM_CLIENTE VARCHAR(150),
VENTA FLOAT,
FEC_DIA DATETIME
)

ALTER PROCEDURE INSERTA_CLIENTE--- (@id_customer nchar(5))
AS 
     BEGIN 
	    INSERT INTO AGR_CLIENTES
	    SELECT A.CustomerID,A.CompanyName , SUM(B.Freight) AS VENTA, GETDATE() AS DIA 
        FROM Customers A
        INNER JOIN Orders B ON A.CustomerID=B.CustomerID
		--WHERE a.CustomerID=@id_customer
        GROUP BY A.CustomerID,A.CompanyName 
     END

EXECUTE INSERTA_CLIENTE ---'ALFKI'

 SELECT *
 FROM AGR_CLIENTES 

 -------------------------------------------------------------	
 ----VIEW, FUNCTION, PROCEDURE, TRIGGERS
 ----CREATE OBJETO NOMBRE DEL OBJETO 
 ----ELIMINAR 
 ----DROP OBJETO NOMBRE DEL OBJETO
 ----ALTER
 -------------------------------------------------------------
 -----TRIGGERS---PARA AUDITORIAS

 CREATE TABLE TB_NOTAS
 ( IDESTUDIANTE INT,
   NOTA1 INT,
   NOTA2 INT,
   PROM FLOAT 
   )
 ---DROP TABLE TB_NOTAS_AUDIT
 CREATE TABLE TB_NOTAS_AUDIT
 (IDESTUDIANTE INT,
  NOTA1 INT,
  NOTA2 INT,
  PROMEDIO FLOAT,
  FEC_OPERACION DATETIME,
  TIPO_T CHAR(5)
  )
  SELECT *  FROM TB_NOTAS_AUDIT
  SELECT *  FROM TB_NOTAS
 
 INSERT INTO TB_NOTAS VALUES(100,14,14,14)
 INSERT INTO TB_NOTAS VALUES(200,15,16,15)

 ----TRIGGER CON INSERT

 CREATE TRIGGER TRG_TB_NOTAS  ---NOMBRE TRIGGER
 ON TB_NOTAS ---NOMBRE DE TABLA ASOCIADA 
 AFTER---TIPO DE TRIGGER 
 INSERT----FUNCION O FUNCIONES EN LAS CUALES EL TRIGGER SE GATILLARA
 AS 
    BEGIN

	INSERT INTO TB_NOTAS_AUDIT
	SELECT IDESTUDIANTE, NOTA1, NOTA2, PROM, GETDATE()
	FROM inserted-----tabla temporal

	END

   ----USANDO EL TRIGGER
  SELECT *  FROM TB_NOTAS_AUDIT
  SELECT *  FROM TB_NOTAS 
 INSERT INTO TB_NOTAS VALUES(200,11,13,15)
 INSERT INTO TB_NOTAS VALUES(100,17,14,14)
  INSERT INTO TB_NOTAS VALUES(1300,17,14)

 -------------------------AGREGANDO CONDICIONALES 
 --DROP TRIGGER TRG_TB_NOTAS2
 --CREATE TRIGGER TRG_TB_NOTAS2  ---NOMBRE TRIGGER
 --ON TB_NOTAS ---NOMBRE DE TABLA ASOCIADA 
 --AFTER---TIPO DE TRIGGER 
 --INSERT----FUNCION O FUNCIONES EN LAS CUALES EL TRIGGER SE GATILLARA
 --AS 
 --   BEGIN

	--DECLARE @PROMEDIO FLOAT

	--SELECT @PROMEDIO=(NOTA1+NOTA2)/2
	--FROM inserted

	--UPDATE TB_NOTAS
	--SET PROM=@PROMEDIO
	--WHERE IDESTUDIANTE IN (SELECT IDESTUDIANTE FROM INSERTED)

	--INSERT INTO TB_NOTAS_AUDIT
	--SELECT IDESTUDIANTE, NOTA1, NOTA2,@PROMEDIO, GETDATE()
	--FROM inserted-----tabla temporal

	--END

  SELECT *  FROM TB_NOTAS_AUDIT
  SELECT *  FROM TB_NOTAS 
----------proceso para actualizar la informacion del promedio en caso no se haya ingresado
  INSERT INTO TB_NOTAS
  (IDESTUDIANTE, NOTA1, NOTA2)
  VALUES(1300,17,14)
 
	CREATE PROCEDURE UPDATE_PROM
	AS

	BEGIN
	  
	     UPDATE TB_NOTAS
		 SET PROM=(NOTA1+NOTA2)/2
		 WHERE PROM IS NULL

	END

	EXECUTE UPDATE_PROM
-----------------------------------------------------------------
----------------TRIGGER CONTEMPLANDO EL DELETE----ES RECOMEDABLE USAR ESTO CUANDO VARIOS USUARIOS TIENEN ACCESO A LECTURA Y ESCRITURA DE LA BASE DE DATOS
ALTER TRIGGER TRG_TB_NOTAS  ---NOMBRE TRIGGER
 ON TB_NOTAS ---NOMBRE DE TABLA ASOCIADA 
 AFTER---TIPO DE TRIGGER 
 INSERT, DELETE ----FUNCION O FUNCIONES EN LAS CUALES EL TRIGGER SE GATILLARA
 AS 
    BEGIN

	INSERT INTO TB_NOTAS_AUDIT
	SELECT IDESTUDIANTE, NOTA1, NOTA2, PROM, GETDATE(),'I'
	FROM inserted-----tabla temporal
	UNION ALL
	SELECT IDESTUDIANTE, NOTA1,NOTA2,PROM,GETDATE(),'D'
	FROM deleted 

	END
	   ----USANDO EL TRIGGER CON DELETE 

  INSERT INTO TB_NOTAS VALUES(600,14,14,14)
  DELETE FROM TB_NOTAS
  WHERE IDESTUDIANTE=500
  SELECT *  FROM TB_NOTAS_AUDIT
  SELECT *  FROM TB_NOTAS 


  ------TRIGGER PARA UPDATE

 ALTER TRIGGER TRG_TB_NOTAS_UP  ---NOMBRE TRIGGER
 ON TB_NOTAS ---NOMBRE DE TABLA ASOCIADA 
 AFTER---TIPO DE TRIGGER 
 UPDATE ----FUNCION O FUNCIONES EN LAS CUALES EL TRIGGER SE GATILLARA
 AS 
    BEGIN

	INSERT INTO TB_NOTAS_AUDIT
	SELECT IDESTUDIANTE, NOTA1, NOTA2, PROM, GETDATE(),'UP-I'
	FROM inserted-----tabla temporal
	UNION ALL
	SELECT IDESTUDIANTE, NOTA1,NOTA2,PROM,GETDATE(),'UP-D'
	FROM deleted 

	END
  ----USANDO EL TRIGGER CON UPDATE  

  SELECT *  FROM TB_NOTAS_AUDIT
  SELECT *  FROM TB_NOTAS 

  UPDATE TB_NOTAS 
  SET PROM=15
  WHERE IDESTUDIANTE=100

  --------------------------------------------------------------------------------------
  ------VARIABLES 

  ----EJEMPLO_1
  DECLARE 
  @MI_TEXTO VARCHAR(150)

  BEGIN 
      SET @MI_TEXTO='HOLA MUNDO'

      PRINT('EL TEXTO ES '+@MI_TEXTO)
  END

  -----EJEMPLO_2

  DECLARE 
  @NOMBRE VARCHAR(150),
  @EDAD INT,
  @ACEPTA_DATOS CHAR(2)
  BEGIN 
      SET @NOMBRE='JEAN PIERRE'
	  SET @EDAD=31
	  SET @ACEPTA_DATOS='SI'

	  PRINT('EL NOMBRE DE LA PERSONA ES '+@NOMBRE+' LA EDAD ES '+CAST(@EDAD AS VARCHAR(150)) +' ACEPTA DATOS '+@ACEPTA_DATOS)
  END
----------------OBJECT_ID ES UNA FUNCION QUE RETORNA EL ID DE LA MATA A REGISTRAR 
 SELECT OBJECT_ID(N'TB_NOTAS')

 SELECT *
 FROM SYS.objects ------TODOS LOS OBJETOS DE LA BASE DE DATOS 
 where object_id IN (SELECT OBJECT_ID(N'TB_NOTAS'))